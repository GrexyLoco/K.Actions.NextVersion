# üöÄ K.Actions.NextVersion

## üåü Release-basierte Semantic Versioning f√ºr PowerShell Module

[![GitHub Release](https://img.shields.io/github/v/release/GrexyLoco/K.Actions.NextVersion)](https://github.com/GrexyLoco/K.Actions.NextVersion/releases)
[![License](https://img.shields.io/github/license/GrexyLoco/K.Actions.NextVersion)](LICENSE)
[![PowerShell](https://img.shields.io/badge/PowerShell-5.1%2B-blue.svg)](https://github.com/PowerShell/PowerShell)
[![Pester Tests](https://img.shields.io/badge/Tests-Pester-green.svg)](Tests/)

**Die intelligenteste GitHub Action f√ºr automatisches Semantic Versioning von PowerShell-Modulen!** 

Vergiss manuell verwaltete Versionsnummern - diese Action analysiert **nur bei Releases** (Push/Merge in den Hauptbranch) alle seit dem letzten Release eingegangenen Branches und bestimmt die perfekte n√§chste Version.

---

## üéØ Das Problem, das wir l√∂sen

**Ohne diese Action:**
- ‚ùå Manuelles Versionieren bei jedem Release
- ‚ùå Vergessene Version-Bumps f√ºhren zu Chaos
- ‚ùå Inkonsistente Versioning-Strategien im Team  
- ‚ùå Aufw√§ndige Code-Reviews f√ºr Versionsnummern
- ‚ùå Per-Commit-Versioning f√ºhrt zu Versions-Inflation

**Mit K.Actions.NextVersion:**
- ‚úÖ **Release-basierte Analyse** - Nur bei tats√§chlichen Releases
- ‚úÖ **Intelligente Merge-Commit-Analyse** seit letztem Git-Tag
- ‚úÖ **Vollautomatisch** - Kein manueller Eingriff n√∂tig
- ‚úÖ **Team-freundlich** - Jeder kann nach bekannten Konventionen arbeiten
- ‚úÖ **Semantic Versioning konform** - Professionelle Versionierung

---

## üìã Wie es funktioniert

### üîç **Release-basierte Analyse (Das Geheimnis)**

Anstatt jeden Commit zu analysieren, wartet diese Action auf **echte Releases**:

1. **Trigger:** Push oder Merge in den Hauptbranch (main/master)
2. **Git-Tag-Discovery:** Findet automatisch den h√∂chsten Semantic Version Tag
3. **Merge-Analyse:** `git log --merges --since="v1.2.3"` analysiert alle Merge-Commits seit letztem Release
4. **Intelligente Bewertung:** Extrahiert Branch-Namen und Commit-Messages aus Merges
5. **Version-Bump:** Bestimmt den h√∂chsten gefundenen Bump-Typ (major > minor > patch)

**Warum Merge-basiert?** 
- ‚úÖ Analysiert nur abgeschlossene Features (keine Work-in-Progress-Commits)
- ‚úÖ Ber√ºcksichtigt alle eingegangenen Branches seit letztem Release
- ‚úÖ Vermeidet Versions-Inflation durch Zwischenst√§nde
- ‚úÖ Cherry-Picks werden automatisch erfasst (sind auch Merges)

### üè∑Ô∏è **Semantic Versioning in Aktion**

```
v1.2.3 ‚Üí Letztes Release (Git Tag)
   ‚Üì
[Merge] feature/user-auth     ‚Üí Minor (Neue Funktion)
[Merge] bugfix/login-fix      ‚Üí Patch (Bugfix)  
[Merge] major/api-rewrite     ‚Üí Major (Breaking Change)
   ‚Üì
v2.0.0 ‚Üí Neues Release (Major gewinnt!)
```

---

## üé® Branch-Naming-Konventionen

Diese Action versteht deine Branching-Strategie automatisch:

###  **Minor Version (X.Y.0) - Neue Features**
```bash
feature/user-authentication  # Neue Login-Funktion
feature/advanced-logging     # Erweiterte Logging-Capabilities
feature/export-pdf          # PDF-Export hinzuf√ºgen
```

### üü¢ **Patch Version (X.Y.Z) - Bugfixes & Refactoring**
```bash
bugfix/memory-leak          # Speicher-Leck beheben
bugfix/validation-error     # Validierungsfehler fixen
refactor/code-cleanup       # Code-Bereinigung
refactor/performance        # Performance-Optimierung
hotfix/security-patch       # Kritischer Security-Fix
```

**Case-Insensitive:** `FEATURE/`, `Feature/`, `feature/` funktionieren alle gleich!

---

## üí¨ Commit-Message-Override

**Commit-Messages haben IMMER Vorrang!** Perfekt f√ºr Ausnahmen und spezielle Releases:

### üî• **Breaking Changes forcieren**
```bash
git commit -m "BREAKING: Remove deprecated login API"
git commit -m "MAJOR: Change configuration file format"

# Mit Alpha/Beta-Kennzeichnung:
git commit -m "BREAKING-ALPHA: New API structure (testing phase)"
git commit -m "MAJOR-BETA: Complete rewrite (beta release)"
```

### ‚≠ê **Features explizit markieren**  
```bash
git commit -m "FEAT: Add OAuth2 authentication support"
git commit -m "FEATURE: Implement advanced search filters"
git commit -m "MINOR: Add configuration validation"

# Mit Alpha/Beta-Kennzeichnung:
git commit -m "FEAT-ALPHA: Experimental search feature"
git commit -m "FEATURE-BETA: Advanced logging (beta)"
```

### üõ†Ô∏è **Patches und Fixes**
```bash
git commit -m "FIX: Resolve null reference exception"
git commit -m "BUGFIX: Handle empty input gracefully"  
git commit -m "HOTFIX: Critical security vulnerability"
git commit -m "PATCH: Update documentation links"

# Mit Alpha/Beta-Kennzeichnung:
git commit -m "FIX-ALPHA: Experimental memory optimization"
git commit -m "HOTFIX-BETA: Security patch (testing)"
```

**Priorit√§t-System:** `MAJOR/BREAKING > MINOR/FEAT > PATCH/FIX`

**Alpha/Beta-Releases:**
- üì¶ **-ALPHA:** Wird zu `1.3.0-alpha` (experimentelle Features)
- üß™ **-BETA:** Wird zu `1.3.0-beta` (testing phase)
- ‚úÖ **Normal:** Wird zu `1.3.0` (stable release)

---

## üîß Eingaben (Inputs)

| Parameter | Beschreibung | Erforderlich | Standard | Beispiel |
|-----------|--------------|--------------|----------|----------|
| `manifestPath` | Pfad zur PowerShell-Manifest-Datei (`.psd1`) | ‚ùå | Auto-Discovery | `"./MyModule/MyModule.psd1"` |
| `branchName` | Git-Branch-Name f√ºr Analyse | ‚ùå | `${{ github.ref_name }}` | `"main"` |
| `commitMessage` | Commit-Message f√ºr Keyword-Analyse (Legacy) | ‚ùå | `""` | `"FEAT: Add new feature"` |
| `targetBranch` | Ziel-Branch f√ºr Release-Analyse | ‚ùå | Auto-Discovery | `"main"` |

### üîç **Auto-Discovery Features**

**Manifest-Discovery:**
```powershell
# Sucht automatisch nach *.psd1 Dateien:
MyProject/
‚îú‚îÄ‚îÄ src/MyModule/MyModule.psd1  ‚úÖ Gefunden!
‚îú‚îÄ‚îÄ tests/TestModule.psd1       ‚ö†Ô∏è  Warnung bei mehreren
‚îî‚îÄ‚îÄ docs/                       
```

**Target-Branch-Discovery:**
```powershell
# Intelligent Branch Detection:
1. git symbolic-ref refs/remotes/origin/HEAD  # GitHub Default
2. Verf√ºgbare Branches: main, master, release, develop
3. Fallback: 'main'
```

---

## üì§ Ausgaben (Outputs)

| Output | Beschreibung | Beispiel | Verwendung |
|--------|--------------|----------|------------|
| `currentVersion` | Aktuelle Version aus Manifest | `"1.2.3"` | Logging, Release Notes |
| `bumpType` | Art des Version-Bumps | `"minor"` | Conditional Steps |
| `newVersion` | Berechnete neue Version | `"1.3.0"` | **Hauptoutput f√ºr Updates** |
| `lastReleaseTag` | Letzter Git Release-Tag | `"v1.2.3"` | Release Notes, Changelogs |
| `targetBranch` | Verwendeter Ziel-Branch | `"main"` | Debugging, Validation |

---

## üöÄ Schnellstart - In 5 Minuten einsatzbereit

### 1Ô∏è‚É£ **Einfachste Verwendung (Zero Config)**

```yaml
name: Auto Version
on:
  push:
    branches: [ main, master ]

jobs:
  version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ‚ö†Ô∏è Wichtig f√ºr Git-Tag-Analyse!
          
      - name: Calculate Next Version
        id: version
        uses: GrexyLoco/K.Actions.NextVersion@v1
        
      - name: Show Result  
        run: |
          echo "Current: ${{ steps.version.outputs.currentVersion }}"
          echo "Bump Type: ${{ steps.version.outputs.bumpType }}"
          echo "New Version: ${{ steps.version.outputs.newVersion }}"
```

### 2Ô∏è‚É£ **Erweiterte Konfiguration**

```yaml
- name: Calculate Next Version
  id: version
  uses: GrexyLoco/K.Actions.NextVersion@v1
  with:
    manifestPath: './src/MyModule/MyModule.psd1'
    targetBranch: 'main'
```

### 3Ô∏è‚É£ **Vollst√§ndiger Release-Workflow**

```yaml
name: PowerShell Module Release
on:
  push:
    branches: [ main ]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Calculate Next Version
        id: version
        uses: GrexyLoco/K.Actions.NextVersion@v1
        
      - name: Update Module Manifest
        run: |
          $manifestPath = "${{ steps.version.outputs.manifestPath }}"
          $newVersion = "${{ steps.version.outputs.newVersion }}"
          
          # Update PowerShell Module Version
          Update-ModuleManifest -Path $manifestPath -ModuleVersion $newVersion
        shell: pwsh
        
      - name: Create Git Tag
        if: steps.version.outputs.bumpType != 'none'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "v${{ steps.version.outputs.newVersion }}"
          git push origin "v${{ steps.version.outputs.newVersion }}"
          
      - name: Create GitHub Release
        if: steps.version.outputs.bumpType != 'none'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ steps.version.outputs.newVersion }}"
          release_name: "Release v${{ steps.version.outputs.newVersion }}"
          body: |
            ## Changes since ${{ steps.version.outputs.lastReleaseTag }}
            
            **Version Bump:** ${{ steps.version.outputs.bumpType }}
            **Previous Version:** ${{ steps.version.outputs.currentVersion }}
            **New Version:** ${{ steps.version.outputs.newVersion }}
```

---

## üéÆ Anwendungsbeispiele

### üåü **Szenario 1: Feature-Entwicklung**

**Entwickler-Workflow:**
```bash
# Feature Branch erstellen
git checkout -b feature/user-authentication
git commit -m "Implement OAuth2 login system"
git commit -m "Add user role management"
git push origin feature/user-authentication

# Pull Request erstellen und mergen in main
# ‚Üí Action erkennt: feature/* = Minor Version Bump
```

**Ergebnis:** `1.2.3` ‚Üí `1.3.0` ‚úÖ

### üî• **Szenario 2: Breaking Change Override**

**Entwickler-Workflow:**
```bash
# Breaking Change per Commit-Message forcieren
git checkout -b bugfix/api-signature
git commit -m "BREAKING: Change login API signature for security"
git push origin bugfix/api-signature

# Pull Request mergen
# ‚Üí Action erkennt: BREAKING √ºbersteuert bugfix/* 
```

**Ergebnis:** `1.2.3` ‚Üí `2.0.0` ‚úÖ

### üß™ **Szenario 3: Alpha-Release f√ºr Testing**

**Entwickler-Workflow:**
```bash
# Experimentelles Feature als Alpha markieren
git checkout -b feature/experimental-search
git commit -m "FEAT-ALPHA: New search algorithm (experimental)"
git push origin feature/experimental-search

# Pull Request mergen
# ‚Üí Action erkennt: FEAT-ALPHA = Minor + Alpha Suffix
```

**Ergebnis:** `1.2.3` ‚Üí `1.3.0-alpha` ‚úÖ

### üõ†Ô∏è **Szenario 4: Hotfix-Release**

**Entwickler-Workflow:**
```bash
git checkout -b hotfix/critical-security
git commit -m "HOTFIX: Resolve critical security vulnerability CVE-2024-xxxx"
git push origin hotfix/critical-security

# Emergency Merge in main
# ‚Üí Action erkennt: HOTFIX = Patch Bump
```

**Ergebnis:** `1.2.3` ‚Üí `1.2.4` ‚úÖ

### üîÑ **Szenario 5: Erstes Release (Keine Tags)**

**Repository-Zustand:**
```bash
# Neues Repository ohne Git-Tags
git log --oneline
abc123 Add initial module structure
def456 Implement core functionality  
```

**Action-Verhalten:**
- ‚úÖ Erkennt: "Erstes Release"
- ‚úÖ Analysiert alle Commits seit Repository-Start  
- ‚úÖ Beginnt bei Version `0.0.1` statt `0.0.0`

**Ergebnis:** `1.0.0` ‚Üí `0.0.1` (erste Release) ‚úÖ

---

## üîß Erweiterte Konfiguration

### üéõÔ∏è **Conditional Steps basierend auf Bump-Type**

```yaml
- name: Major Release Actions
  if: steps.version.outputs.bumpType == 'major'
  run: |
    echo "üö® Major Release detected!"
    echo "‚Üí Notify breaking changes to users"
    echo "‚Üí Update documentation"
    echo "‚Üí Send breaking change notifications"
    
- name: Minor Release Actions  
  if: steps.version.outputs.bumpType == 'minor'
  run: |
    echo "‚≠ê New features added!"
    echo "‚Üí Update feature documentation"
    echo "‚Üí Generate changelog"
    
- name: Patch Release Actions
  if: steps.version.outputs.bumpType == 'patch'  
  run: |
    echo "üõ†Ô∏è Bug fixes applied!"
    echo "‚Üí Notify bug resolution"
```

### üè∑Ô∏è **Multi-Environment Releases**

```yaml
- name: Development Release
  if: github.ref == 'refs/heads/develop'
  uses: GrexyLoco/K.Actions.NextVersion@v1
  with:
    targetBranch: 'develop'
    
- name: Production Release
  if: github.ref == 'refs/heads/main'  
  uses: GrexyLoco/K.Actions.NextVersion@v1
  with:
    targetBranch: 'main'
```

### üìä **Release Notes Generierung**

```yaml
- name: Generate Detailed Release Notes
  run: |
    $lastTag = "${{ steps.version.outputs.lastReleaseTag }}"
    $newVersion = "${{ steps.version.outputs.newVersion }}"
    $targetBranch = "${{ steps.version.outputs.targetBranch }}"
    
    # Alle Merge-Commits seit letztem Release
    if ($lastTag) {
      $merges = git log --merges --oneline --format="%s" "$lastTag..$targetBranch"
    } else {
      $merges = git log --merges --oneline --format="%s" $targetBranch
    }
    
    echo "## Release Notes v$newVersion" > RELEASE_NOTES.md
    echo "" >> RELEASE_NOTES.md
    echo "### Merged Features & Fixes:" >> RELEASE_NOTES.md
    $merges | ForEach-Object { echo "- $_" >> RELEASE_NOTES.md }
  shell: pwsh
```

---

## üõ†Ô∏è Troubleshooting & FAQ

### ‚ùì **H√§ufige Probleme**

#### üö´ **"No git tags found" - Erstes Release**
**Problem:** Repository hat noch keine Git-Tags
```
üéâ No previous releases found - this will be the first release!
```

**L√∂sung:** Normal! Die Action:
- ‚úÖ Analysiert alle Commits seit Repository-Start
- ‚úÖ Beginnt bei Version `0.0.1`  
- ‚úÖ Wendet erkannte Bump-Types an

#### üö´ **"Not on target branch" - Falsche Branch**
**Problem:** Action l√§uft auf Feature-Branch statt main/master
```
‚ÑπÔ∏è Not on target branch 'main', no version bump needed
```

**L√∂sung:** Workflow nur auf Haupt-Branches ausf√ºhren:
```yaml
on:
  push:
    branches: [ main, master ]  # ‚úÖ Nur auf Release-Branches
```

#### üö´ **"Multiple .psd1 files found" - Mehrere Manifeste**
**Problem:** Auto-Discovery findet mehrere PowerShell-Manifeste
```
‚ö†Ô∏è Multiple .psd1 files found. Using first one: ./src/Module.psd1
Available manifests: ./src/Module.psd1, ./tests/TestModule.psd1
```

**L√∂sung:** Expliziten Pfad angeben:
```yaml
with:
  manifestPath: './src/MyModule/MyModule.psd1'  # ‚úÖ Eindeutig
```

#### üö´ **Git History Probleme**
**Problem:** Shallow Clone verhindert Tag-Analyse
```
‚ö†Ô∏è Failed to retrieve git tags: fatal: not a git repository
```

**L√∂sung:** Full Git History abrufen:
```yaml
- uses: actions/checkout@v4
  with:
    fetch-depth: 0  # ‚úÖ Komplette Git-History
```

### üí° **Pro-Tips**

#### üéØ **Branch Protection Rules**
```bash
# Verhindert direkte Commits in main (empfohlen):
# GitHub ‚Üí Settings ‚Üí Branches ‚Üí Add rule
# ‚úÖ Require pull request reviews before merging
# ‚úÖ Dismiss stale PR approvals when new commits are pushed
```

#### üè∑Ô∏è **Tag-Naming-Convention**
```bash
# Empfohlene Git-Tag-Formate (alle unterst√ºtzt):
git tag v1.2.3      # ‚úÖ Mit 'v' Prefix (empfohlen)
git tag 1.2.3       # ‚úÖ Ohne Prefix  
git tag V1.2.3      # ‚ùå Gro√ü-V wird nicht erkannt
```

#### üìù **Commit-Message-Best-Practices**
```bash
# ‚úÖ Empfohlene Formate:
git commit -m "FEAT: Add user authentication system"
git commit -m "FIX: Resolve memory leak in logger"
git commit -m "BREAKING: Remove deprecated API endpoints"

# ‚ùå Vermeiden:
git commit -m "Fixed stuff"
git commit -m "Updates"
```

---

## üß™ Testen der Action

### üî¨ **Lokaler Test mit PowerShell**

```powershell
# Direkte Ausf√ºhrung zum Testen
.\Get-NextVersion.ps1 -ManifestPath ".\MyModule.psd1" -BranchName "feature/test" -TargetBranch "main"

# Mit Verbose Output f√ºr Debugging
.\Get-NextVersion.ps1 -Verbose
```

### üé≠ **Mock-Szenarien f√ºr Tests**

```powershell
# Test verschiedener Branch-Patterns
.\Get-NextVersion.ps1 -BranchName "major/rewrite" -TargetBranch "master"     # ‚Üí major
.\Get-NextVersion.ps1 -BranchName "feature/new-api" -TargetBranch "master"   # ‚Üí minor  
.\Get-NextVersion.ps1 -BranchName "bugfix/critical" -TargetBranch "master"   # ‚Üí patch

# Test Commit-Message-Override
.\Get-NextVersion.ps1 -BranchName "bugfix/small" -CommitMessage "BREAKING: API Change"  # ‚Üí major
```

### üß™ **Pester Tests ausf√ºhren**

```powershell
# Vollst√§ndige Test-Suite ausf√ºhren
Invoke-Pester .\Tests\Get-NextVersion.Tests.ps1 -Output Detailed

# Bestimmte Test-Kategorien
Invoke-Pester .\Tests\Get-NextVersion.Tests.ps1 -Tag "BranchPatterns"
Invoke-Pester .\Tests\Get-NextVersion.Tests.ps1 -Tag "CommitMessages"
```

---

## ü§ù Contributing & Support

### üêõ **Bug Reports**
Gefunden einen Fehler? [Erstelle ein Issue](https://github.com/GrexyLoco/K.Actions.NextVersion/issues) mit:
- ‚úÖ PowerShell-Version (`$PSVersionTable.PSVersion`)
- ‚úÖ Workflow-Konfiguration
- ‚úÖ Erwartetes vs. tats√§chliches Verhalten
- ‚úÖ Relevante Logs aus der Action

### üí° **Feature Requests**  
Neue Ideen? [Feature Request erstellen](https://github.com/GrexyLoco/K.Actions.NextVersion/issues) mit:
- ‚úÖ Beschreibung des gew√ºnschten Features
- ‚úÖ Anwendungsfall / Use Case
- ‚úÖ Beispiel-Konfiguration (falls m√∂glich)

### üîß **Pull Requests**
Verbesserungen willkommen! Bitte:
- ‚úÖ Fork das Repository
- ‚úÖ Erstelle Feature-Branch (`feature/amazing-feature`)
- ‚úÖ F√ºge Tests hinzu (`Tests/Get-NextVersion.Tests.ps1`)
- ‚úÖ Dokumentation aktualisieren
- ‚úÖ Pull Request erstellen

---

## üìù Lizenz

Dieses Projekt ist unter der [MIT License](LICENSE) lizenziert.

---

## ‚≠ê Gef√§llt dir diese Action?

Wenn dir K.Actions.NextVersion geholfen hat:
- ‚≠ê **Star** das Repository  
- üç¥ **Fork** f√ºr eigene Anpassungen
- üì¢ **Teile** mit deinem Team
- üêõ **Melde Bugs** oder **Verbesserungsvorschl√§ge**

**Happy Versioning! üöÄ**

---

<div align="center">

**Made with ‚ù§Ô∏è for the PowerShell Community**

[![PowerShell Gallery](https://img.shields.io/badge/PowerShell-Gallery-blue.svg)](https://www.powershellgallery.com/)
[![GitHub](https://img.shields.io/badge/GitHub-Actions-black.svg)](https://github.com/features/actions)

</div>

### ‚ú® Minor Version Keywords  
| Keyword | Beschreibung | Beispiel |
|---------|--------------|----------|
| `MINOR` | Minor Version Bump | `MINOR: Add user authentication feature` |
| `FEATURE` | New Feature | `FEATURE: Implement advanced logging` |
| `FEAT` | New Feature (short) | `FEAT: Add configuration validation` |

### üîß Patch Version Keywords
| Keyword | Beschreibung | Beispiel |
|---------|--------------|----------|
| `PATCH` | Patch Version Bump | `PATCH: Update documentation links` |
| `FIX` | Bug Fix | `FIX: Resolve memory leak in data processing` |
| `BUGFIX` | Bug Fix (explicit) | `BUGFIX: Handle null reference exceptions` |
| `HOTFIX` | Critical Fix | `HOTFIX: Emergency security vulnerability patch` |

> üéØ **Wichtig:** Alle Keywords sind **case-insensitive** und k√∂nnen √ºberall in der Commit-Message stehen!

**Praktisches Beispiel der Priorit√§t:**
```bash
# Branch: feature/new-api (w√ºrde normalerweise minor geben)
# Commit: "BREAKING: Change all function signatures"  
# Ergebnis: MAJOR bump (2.0.0) - Commit override gewinnt!

# Branch: bugfix/memory-leak (w√ºrde normalerweise patch geben)
# Commit: "FEAT: Add memory optimization feature"
# Ergebnis: MINOR bump (1.3.0) - Commit override gewinnt!
```

## üöÄ Verwendung

### Basis-Setup

```yaml
name: Version Management
on:
  push:
    branches: [main, develop]
  pull_request:

jobs:
  version:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get Next Version
        id: version
        uses: GrexyLoco/K.Actions.NextVersion@v1
        with:
          manifestPath: './MyModule/MyModule.psd1'
          branchName: ${{ github.ref_name }}
          commitMessage: ${{ github.event.head_commit.message }}

      - name: Display Version Info
        run: |
          echo "Current Version: ${{ steps.version.outputs.currentVersion }}"
          echo "Bump Type: ${{ steps.version.outputs.bumpType }}"
          echo "New Version: ${{ steps.version.outputs.newVersion }}"
```

### Erweiterte Verwendung mit Auto-Discovery

```yaml
- name: Auto-Discover and Version
  id: auto-version
  uses: GrexyLoco/K.Actions.NextVersion@v1
  # Keine Inputs erforderlich - Auto-Discovery aktiviert

- name: Create Release
  if: github.ref == 'refs/heads/main'
  uses: actions/create-release@v1
  with:
    tag_name: v${{ steps.auto-version.outputs.newVersion }}
    release_name: Release ${{ steps.auto-version.outputs.newVersion }}
    body: |
      ## Version ${{ steps.auto-version.outputs.newVersion }}
      
      **Bump Type:** ${{ steps.auto-version.outputs.bumpType }}
      **Previous Version:** ${{ steps.auto-version.outputs.currentVersion }}
      
      Auto-generated release based on semantic versioning.
```

### Conditional Versioning Workflow

```yaml
- name: Determine Version Strategy
  id: versioning
  uses: GrexyLoco/K.Actions.NextVersion@v1

- name: Major Version Actions
  if: steps.versioning.outputs.bumpType == 'major'
  run: |
    echo "üö® Major version detected - running breaking change validations"
    # Zus√§tzliche Tests f√ºr breaking changes

- name: Feature Release Actions  
  if: steps.versioning.outputs.bumpType == 'minor'
  run: |
    echo "‚ú® New feature detected - updating feature documentation"
    # Feature-spezifische Aktionen

- name: Patch Release Actions
  if: steps.versioning.outputs.bumpType == 'patch'
  run: |
    echo "üîß Patch release - running regression tests"
    # Patch-spezifische Validierungen
```

## üîç Beispiele

### Feature Branch
```yaml
# Branch: feature/enhanced-logging
# Manifest: ModuleVersion = '1.2.3'
# Output: 
#   currentVersion: '1.2.3'
#   bumpType: 'minor'
#   newVersion: '1.3.0'
```

### Bugfix mit Breaking Change
```yaml
# Branch: bugfix/api-fix
# Commit: "BREAKING: Change parameter order in Get-Data function"
# Manifest: ModuleVersion = '1.2.3'
# Output:
#   currentVersion: '1.2.3'
#   bumpType: 'major'
#   newVersion: '2.0.0'
```

### Major Branch
```yaml
# Branch: major/v2-rewrite
# Manifest: ModuleVersion = '1.9.5'
# Output:
#   currentVersion: '1.9.5'
#   bumpType: 'major'
#   newVersion: '2.0.0'
```

## üõ†Ô∏è Lokale Entwicklung

### PowerShell-Skript testen

```powershell
# Basis-Test
.\Get-NextVersion.ps1 -ManifestPath ".\MyModule.psd1" -BranchName "feature/test" -CommitMessage "Add new feature"

# Mit Verbose-Ausgabe
.\Get-NextVersion.ps1 -ManifestPath ".\MyModule.psd1" -BranchName "major/rewrite" -Verbose

# Breaking Change Test
.\Get-NextVersion.ps1 -BranchName "bugfix/fix" -CommitMessage "BREAKING: Remove old API"
```

### Action lokal testen

```bash
# Mit act (GitHub Actions local runner)
act -j version-test --secret GITHUB_TOKEN=your_token

# Oder mit Docker
docker run --rm -v "${PWD}:/workspace" -w /workspace \
  nektos/act:latest -j version-test
```

## üìã Anforderungen

- **PowerShell 5.1+** oder **PowerShell Core 6.0+**
- **G√ºltiges PowerShell-Manifest** (`.psd1`) mit `ModuleVersion`
- **Git-Repository** mit strukturierten Branch-Namen

## üêõ Troubleshooting

### H√§ufige Probleme

**Problem:** `PowerShell manifest file not found`
```yaml
# L√∂sung: Expliziten Pfad angeben
- uses: GrexyLoco/K.Actions.NextVersion@v1
  with:
    manifestPath: './src/MyModule/MyModule.psd1'
```

**Problem:** `ModuleVersion not found in manifest`
```powershell
# L√∂sung: Manifest-Datei validieren
@{
    ModuleVersion = '1.0.0'  # ‚Üê Erforderlich!
    # ... andere Eigenschaften
}
```

**Problem:** Unerwarteter Bump-Type
```yaml
# L√∂sung: Branch-Pattern √ºberpr√ºfen oder Commit-Message
# Branch: fix/bug      ‚Üí patch (erwartet)
# Branch: feature/fix  ‚Üí minor (erwartet)  
# Branch: FEATURE/fix  ‚Üí minor (case-insensitive!)
# Commit: "BREAKING"   ‚Üí major (override)
```

## üß™ Tests ausf√ºhren

```powershell
# Pester-Tests lokal ausf√ºhren
cd Tests
Invoke-Pester .\Get-NextVersion.Tests.ps1

# Einfacher Test
.\Test-Action.ps1

# Mit spezifischen Parametern testen
.\Get-NextVersion.ps1 -ManifestPath ".\TestModule.psd1" -BranchName "Feature/NEW-API" -Verbose
```

## ü§ù Beitragen

1. **Fork** das Repository
2. **Branch** erstellen (`git checkout -b feature/amazing-feature`)
3. **Commit** √Ñnderungen (`git commit -m 'Add amazing feature'`)
4. **Push** zum Branch (`git push origin feature/amazing-feature`)
5. **Pull Request** √∂ffnen

## üìÑ Lizenz

Dieses Projekt ist unter der [MIT License](LICENSE) lizenziert.

## üôè Danksagungen

- [Semantic Versioning](https://semver.org/) f√ºr die Versionierungsstandards
- [GitHub Actions](https://github.com/features/actions) f√ºr die CI/CD-Platform
- PowerShell-Community f√ºr die gro√üartigen Tools und Inspiration

---

**Erstellt mit ‚ù§Ô∏è f√ºr die PowerShell- und DevOps-Community**